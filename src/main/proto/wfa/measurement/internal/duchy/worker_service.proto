syntax = "proto3";

package wfa.measurement.internal.duchy;

option java_package = "org.wfanet.measurement.internal.duchy";
option java_multiple_files = true;

// Service definition for worker to worker communication. The messages passed
// here cause state transitions.
service WorkerService {

  // Transmits a noisy sparse encrypted sketches needed for a computation to
  // the primary worker. Sketches can exceed the maximum message size so the
  // client should stream requests containing sequential chunks of the sketch.
  rpc TransmitNoisedSketch(stream TransmitNoisedSketchRequest)
      returns (TransmitNoisedSketchResponse) {}

  // Tell a worker to decrypt the positional argument of a register three-tuple
  // with its non-deterministic private key, and re-encrypt the same value with
  // a deterministic key. Sketches can exceed the maximum message size so the
  // client should stream requests containing sequential chunks of the sketch.
  rpc BlindPositions(stream BlindPositionsRequest) returns (BlindPositionsResponse) {}

  // Decrypt the flag and count values inside the sketch. Sketches can exceed
  // the maximum message size so the client should stream requests containing
  // sequential chunks of the sketch.
  rpc DecryptFlagAndCount(stream DecryptFlagAndCountRequest)
      returns (DecryptFlagAndCountResponse) {}

  // For debugging. When the WorkerService receives this request if the count
  // is larger than 0 it reduces the count by 1 and sends a TraceRequest to the
  // next WorkerService. It returns a list of hops including the name of the
  // server and the count it received in the request.
  rpc Trace(TraceRequest) returns (TraceResponse) {}
}

// Transmit sketches for a computation to the primary worker.
message TransmitNoisedSketchRequest {
  // The identifier of the multi-party computation to start.
  uint64 computation_id = 1;

  // The sketch contains a list of registers each is a three tuple of position,
  // key, and count. Sketches can exceed the maximum message size so split them
  // into chunks and send a sequence of requests via the stream.
  bytes partial_sketch = 2;
}

message TransmitNoisedSketchResponse {}

// Tell a worker to decrypt with its non-deterministic key and re-encrypt with
// a deterministic key the positional index item of an array of ThreeTuples.
message BlindPositionsRequest {
  // The identifier of the multi-party computation to start.
  uint64 computation_id = 1;

  // The sketch contains a list of registers each is a three tuple of position,
  // key, and count. Sketches can exceed the maximum message size so split them
  // into chunks and send a sequence of requests via the stream.
  bytes partial_sketch = 4;
}

message BlindPositionsResponse {
  // Deliberately empty
}

message DecryptFlagAndCountRequest {
  // The identifier of the multi-party computation to start.
  uint64 computation_id = 1;

  // The sketch contains a list of registers each is a flag count pair.
  // Sketches can exceed the maximum message size so split them into chunks and
  // send a sequence of requests via the stream.
  bytes partial_sketch = 2;
}

message DecryptFlagAndCountResponse {
  // Deliberately empty
}

message TraceRequest {
  int32 count = 1;
}

message TraceResponse {
  repeated Hop hop = 2;

  message Hop {
    string name = 1;
    int32 countdown = 2;
  }
}
