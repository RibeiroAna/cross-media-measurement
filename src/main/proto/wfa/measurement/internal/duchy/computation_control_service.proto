syntax = "proto3";

package wfa.measurement.internal.duchy;

option java_package = "org.wfanet.measurement.internal.duchy";
option java_multiple_files = true;

// Service definition for worker to worker communication. The messages passed
// here cause stage transitions.
service ComputationControlService {
  // Stores the concatenated, noisy sparse encrypted sketch from a secondary
  // duchy at the primary duchy. Once the primary has sketches from all
  // secondary duchies it can start executing the computation.
  //
  // Sketches can exceed the maximum message size so the client should
  // stream requests containing sequential chunks of the sketch,
  // but the entire sketch should be uploaded in a single stream.
  rpc HandleNoisedSketch(stream HandleNoisedSketchRequest)
      returns (HandleNoisedSketchResponse) {}

  // Stores the concatenated, noisy sparse encrypted sketch for the entire
  // computation at a duchy. The duchy will then decrypt the positional
  // argument of a register three-tuple with its non-deterministic private key,
  // and re-encrypt the same value with a deterministic key. Successful
  // calls to this function signifies that the sketch was stored, not that the
  // re-encryption option was successful.
  //
  // Sketches can exceed the maximum message size so the client should
  // stream requests containing sequential chunks of the sketch,
  // but the entire sketch should be uploaded in a single stream.
  rpc HandleConcatenatedSketch(stream HandleConcatenatedSketchRequest)
      returns (HandleConcatenatedSketchResponse) {}

  // Stores the encrypted flag and count value tuples at the duchy. The duchy
  // will then decrypt the flag and count values inside the sketch. Successful
  // calls to this function signifies that the sketch was stored, not that the
  // cryptographic options were successful.
  rpc HandleEncryptedFlagsAndCounts(stream HandleEncryptedFlagsAndCountsRequest)
      returns (HandleEncryptedFlagsAndCountsResponse) {}
}

// Transmit sketches for a computation from a secondary duchy to the primary worker.
// The primary expects a sketch from all secondary duchies. This request is
// essentially storing a mapping of (computation_id, sender) -> sketch.
message HandleNoisedSketchRequest {
  // The globally unique identifier of the multi-party computation.
  uint64 computation_id = 1;

  // The sketch contains a list of registers each is a three tuple of position,
  // key, and count. Sketches can exceed the maximum message size so split them
  // into chunks and send a sequence of requests via the stream.
  bytes partial_sketch = 2;

  // The identifier of the sender of the noised sketch which is the name of
  // the duchy. This identifier much match a known duchy name that is being
  // used in the computation. It should not contain any whitespace characters.
  string sender = 3;
}

message HandleNoisedSketchResponse {
  // Deliberately empty
}

// Transmits the concatenated sketch from all duchies to another duchy.
// A duchy expects to see this message once per computation and only from
// its predecessor in ring for the computation.
// This request is essentially storing a mapping of (computation_id) -> sketch.
message HandleConcatenatedSketchRequest {
  // The globally unique identifier of the multi-party computation.
  uint64 computation_id = 1;

  // The sketch contains a list of registers each is a three tuple of position,
  // key, and count. Sketches can exceed the maximum message size so split them
  // into chunks and send a sequence of requests via the stream.
  bytes partial_sketch = 4;
}

message HandleConcatenatedSketchResponse {
  // Deliberately empty
}

// Transmits the encrypted flag and count pairs from the combined sketch to another
// duchy. A duchy expects to see this message once per computation and only from
// its predecessor in ring for the computation.
// This request is essentially storing a mapping of (computation_id) -> pairs.
message HandleEncryptedFlagsAndCountsRequest {
  // The globally unique identifier of the multi-party computation.
  uint64 computation_id = 1;

  // The data is a list of flag count pairs. These pairs can exceed the maximum
  // message size so split them into chunks and send a sequence of requests via
  // the stream.
  bytes partial_data = 2;
}

message HandleEncryptedFlagsAndCountsResponse {
  // Deliberately empty
}
