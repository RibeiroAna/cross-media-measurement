// Copyright 2020 The Measurement System Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

syntax = "proto3";

package wfa.measurement.internal.duchy;

option java_package = "org.wfanet.measurement.internal.duchy";
option java_multiple_files = true;

// Service definition for worker to worker communication. The messages passed
// here cause stage transitions.
service ComputationControlService {
  // Stores the concatenated, noisy sparse encrypted sketch from a secondary
  // duchy at the primary duchy. Once the primary has sketches from all
  // secondary duchies it can start executing the computation.
  //
  // Sketches can exceed the maximum message size so the client should
  // stream requests containing sequential chunks of the sketch,
  // but the entire sketch should be uploaded in a single stream.
  rpc HandleNoisedSketch(stream HandleNoisedSketchRequest)
      returns (HandleNoisedSketchResponse) {}

  // Stores the concatenated, noisy sparse encrypted sketch for the entire
  // computation at a duchy. The duchy will then decrypt the positional
  // argument of a register three-tuple with its non-deterministic private key,
  // and re-encrypt the same value with a deterministic key. Successful
  // calls to this function signifies that the sketch was stored, not that the
  // re-encryption option was successful.
  //
  // Sketches can exceed the maximum message size so the client should
  // stream requests containing sequential chunks of the sketch,
  // but the entire sketch should be uploaded in a single stream.
  rpc HandleConcatenatedSketch(stream HandleConcatenatedSketchRequest)
      returns (HandleConcatenatedSketchResponse) {}

  // Stores the encrypted flag and count value tuples at the duchy. The duchy
  // will then decrypt the flag and count values inside the sketch. Successful
  // calls to this function signifies that the sketch was stored, not that the
  // cryptographic options were successful.
  rpc HandleEncryptedFlagsAndCounts(stream HandleEncryptedFlagsAndCountsRequest)
      returns (HandleEncryptedFlagsAndCountsResponse) {}
}

// Transmit sketches for a computation from a secondary duchy to the primary
// worker. The primary expects a sketch from all secondary duchies. This request
// is essentially storing a mapping of (computation_id, sender) -> sketch.
message HandleNoisedSketchRequest {
  // The globally unique identifier of the multi-party computation.
  // Only the first message in the request stream needs to set this value, it
  // will be ignored on all other requests in the stream.
  uint64 computation_id = 1;

  // The sketch contains a list of registers each is a three tuple of position,
  // key, and count. Sketches can exceed the maximum message size so split them
  // into chunks and send a sequence of requests via the stream.
  bytes partial_sketch = 2;
}

message HandleNoisedSketchResponse {
  // Deliberately empty
}

// Transmits the concatenated sketch from all duchies to another duchy.
// A duchy expects to see this message once per computation and only from
// its predecessor in ring for the computation.
// This request is essentially storing a mapping of (computation_id) -> sketch.
message HandleConcatenatedSketchRequest {
  // The globally unique identifier of the multi-party computation.
  // Only the first message in the request stream needs to set this value, it
  // will be ignored on all other requests in the stream.
  uint64 computation_id = 1;

  // The sketch contains a list of registers each is a three tuple of position,
  // key, and count. Sketches can exceed the maximum message size so split them
  // into chunks and send a sequence of requests via the stream.
  bytes partial_sketch = 4;
}

message HandleConcatenatedSketchResponse {
  // Deliberately empty
}

// Transmits the encrypted flag and count pairs from the combined sketch to
// another duchy. A duchy expects to see this message once per computation and
// only from its predecessor in ring for the computation. This request is
// essentially storing a mapping of (computation_id) -> pairs.
message HandleEncryptedFlagsAndCountsRequest {
  // The globally unique identifier of the multi-party computation.
  // Only the first message in the request stream needs to set this value, it
  // will be ignored on all other requests in the stream.
  uint64 computation_id = 1;

  // The data is a list of flag count pairs. These pairs can exceed the maximum
  // message size so split them into chunks and send a sequence of requests via
  // the stream.
  bytes partial_data = 2;
}

message HandleEncryptedFlagsAndCountsResponse {
  // Deliberately empty
}
